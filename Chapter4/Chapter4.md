# 第四章 入门篇(2)——算法初步

## 4.1 排序

### 4.1.1 选择排序

简单选择排序是指，对一个序列A中的元素`A[1] ~ A[n]`，令i从1到n枚举，进行n趟操作，每趟从待排序部分`[i, n]`中选择最小的元素，令其与待排序部分的第一个元素`A[i]`进行交换，这样元素`A[i]`就会与当前有序区间`[1, i - 1]`形成新的有序区间`[1, i]`。于是在n趟操作后，所有元素就会是有序的。

算法逻辑：总共需要进行n趟操作，每趟操作选出待排序部分`[i, n]`中最小的元素，令其与`A[i]`交换，总复杂度为`O(n^2)`。

> 代码示例:

```C++
    void selectSort()
    {
        for(int i = 0; i < n; i++)
        {
            int k = i;
            for(int j = i; j <= n; j++)
            {
                if(A[j] < A[k])
                    k = j;
            }
            int temp = A[i];
            A[i] = A[k];
            A[k] = temp;
        }
    }
```

### 4.1.2 插入排序

直接插入排序是指，对序列A的n个元素`A[1] ~ A[n]`，令i从2到n枚举，进行`n - 1`趟操作。假设某一趟时，序列A的前`i - 1`个元素`A[1] ~ A[i - 1]`已经有序，而范围`[i, n]`还未有序，那么该趟从范围`[1, i - 1]`中寻找某个位置j，使得将`A[i]`插入位置j后（此时`A[j] ~ A[i - 1]`会后移一位至`A[j + 1] ~A[i]`），范围`[1, i]`有序。

插入排序是将待插入元素一个个插入初始已有序部分中的过程，而插入位置的选择遵循了使插入后仍然保持有序的原则，具体做法一般是从后往前枚举已有序部分来确定插入位置。

> 代码示例:

```C++
    int A[maxn], n; // n为元素个数，数组下标为0~n-1
    void insertSort()
    {
        for(int i = 1; i <= n-1; i++)
        {
            int temp = A[i], j = i;
            while(j > 0 && temp < A[j-1])
            {
                A[j] = A[j - 1];
                j--;
            }
            A[j] = temp;
        }
    }
```

### 4.1.3 排序题与sort函数的应用

1. cmp函数的编写

使用sort进行排序时，需要提供cmp函数实现的排序规则。比如，经常会出现类似这样的要求：对所有学生先按分数从高到低排序，分数相同的按姓名的字典序从小到大排序。

需要完成的排序规则可以等价表述如下：

1) 如果两个学生分数不相同， 那么分数高的排在前面。
2) 否则， 将姓名字典序小的排在前面。

> 代码示例:

```C++
    bool cmp(Student a, Student b)
    {
        if(a.score != b.score) return a.score > b.score;
        else return strcmp(a.name, b.name) < 0;
    }
```

`strcmp`函数是`string.h`头文件下用来比较两个`char`型数组的字典序大小的，其中`strcmp(str1, str2)`当`str1`的字典序小于`str2`时返回一个负数，当`str1`的字典序等于`str2`时返回0，当`str1`的字典序大于`str2`时返回—个正数。

> 练习1：

[PAT A1025](https://github.com/Vuean/AlgorithmNote/blob/main/Chapter4/Chapter4/Sec4Exa1A1025/main.cpp)

## 4.2 散列

### 4.2.1 散列的定义与整数散列

一般来说，散列(Hash)可以浓缩成一句话“将元素通过一个函数转换为整数，使得该整数可以尽量唯一地代表这个元素”。其中把这个转换函数称为**散列函数H**，也就是说，如果元素在转换前为key，那么转换后就是一个整数`H(key)`。

那么对key是整数的情况来说，常用的散列函数有**直接定址法(或是线性变换`H(key) = a * key + b`)**、**平方取中法**、**除留余数法**等。

其中，常用的为**除留余数法**，指把key出意一个数mod得到的余数作为hash值得方法，即：`H(key)=key % mod`。

但是通过除留余数法可能会有两个不同的数key1和key2的hash值相同，则会造成hash值冲突。可考虑采用**线性探查法**(**Linear Probing**)、**平方探查法**(**Quadratic probing**)、**链地址法**(**拉链法**)等三种方法，其中前两种均需要计算新的hash值，又称为**开放定址法**。

1. 线性探查法(Linear Probing)

当得到key的hash值`H(key)`，但是表中下标为`H(key)`的位置已经被某个其他元素使用了，那么就检查下一个位置`H(key) + 1` 是否被占，如果没有，就使用这个位置；否则就继续检查下一个位置（也就是将hash值不断加1)。如果检查过程中超过了表长，那么就回到表的首位继续循环，直到找到一个可以使用的位置，或者是发现表中所有位置都已被使用。显然，这个做法容易导致扎堆，即表中连续若干个位置都被使用，这在一定程度上会降低效率。

2. 平方探查法(Quadratic probing)

在平方探查法中，为了尽可能避免扎堆现象，当表中下标为`H(key)`的位置被占时，将按下面的顺序检查表中的位置：`H(key) + 1^2`, `H(key) - 1^2`, `H(key) + 2^2`, `H(key) - 2^2`, `H(key) + 3^2`, ...。如果检查过程中`H(key) + k^2`超过了表长TSize，那么就把`H(key) + k^2`对表长TSize取模；如果检查过程中出现`H(key) - k^2< 0`的情况（假设表的首位为0)，那么将`((H(key) - k^2) % TSize + TSize) % TSize`作为结果（等价于将`H(key) - k^2`不断加上TSize直到出现第一个非负数）。如果想避免负数的麻烦，可以只进行正向的平方探查。可以证明，如果k在`[0, TSize)`范围内都无法找到位置，那么当`k≥TSize`时，也一定无法找到位置。

3. 链地址法(拉链法)

链地址法不计算新的hash值，而是把所有`H(key)`相同的key连接
成一条单链表。这样可以设定一个数组`Link`，范围是`Link[0] ~ Link[mod]`，其中`Link[h]`存放`H(key) = h`的一条单链表，于是当多个关键字key的hash值都是h时，就可以直接把这些冲突的key直接用单链表连接起来，此时就可以遍历这条单链表来寻找所有`H(key) = h`的key。

以上即可构建一对键值对，同时也可通过标准库模板中的map实现。

### 4.2.2 字符串hash初步

字符串hash是指将一个字符串S映射为一个整数，使得该整数可以尽可能唯一地代表字符串S。本节只讨论将字符串转换为唯一的整数，进阶部分
在[12.1]()节。

假设字符串均由大写字母A~Z组成，则不妨将A~Z视为0~25，构成二十六进制，然后再将二十六进制转换为十进制，即可完成字符串到整数的映射。

> 代码示例:

```C++
    int hashFunc(char S[], int len) // hash函数，将字符串S转换为整数
    {
        int id = 0;
        for(int i = 0; i < len; i++)
        {
            id = id * 26 + (S[i] - 'A');
        }
        return id;
    }
```

显然，如果字符串S的长度比较长，那么转换成的整数也会很大，因此需要注意使用时len不能太长。如果字符串中出现了小写字母，那么可以把A ~ Z作为0 ~ 25，而把a ~ z作为26 ~ 51，这样就变成了五十二进制转换为十进制的问题，做法也是相同的：

> 代码示例:

```C++
    int hashFunc(char S[], int len) // hash函数，将字符串S转换为整数
    {
        int id = 0;
        for(int i = 0; i < len; i++)
        {
            if(S[i] >= 'A' && S[i] <= 'Z')
            {
                id = id * 52 + (S[i] - 'A');
            }
            else if(S[i] >= 'a' && S[i] <= 'z')
            {
                id = id * 52 + (S[i] - 'a') + 26;
            }
        }
        return id;
    }
```

而如果出现了数字，一般有两种处理方法：

1. 按照小写字母的处理方法，增大进制数至62；
2. 如果保证在字符串的末尾是确定个数的数字，那么就可以把前面英文字母的部分按上面的思路转换成整数，再将末尾的数字直接拼接上去。

例如对由三个字符加一位数字组成的字符串：

> 代码示例:

```C++
    int hashFunc(char S[], int len) // hash函数，将字符串S转换为整数
    {
        int id = 0;
        for(int i = 0; i < len -1; i++)
        {
            id = id * 26 + (S[i] - 'A');
        }
        id = id * 10 + (S[len-1] - '0');
        return id;
    }
```

给出N个字符串（由恰好三位大写字母组成），再给出M个查询字符串，问每个查询字符串在N个字符串中出现的次数。

> 练习1：

[练习2]()

## 4.3 递归

### 4.3.1 分治

