# 第四章 入门篇(2)——算法初步

## 4.1 排序

### 4.1.1 选择排序

简单选择排序是指，对一个序列A中的元素`A[1] ~ A[n]`，令i从1到n枚举，进行n趟操作，每趟从待排序部分`[i, n]`中选择最小的元素，令其与待排序部分的第一个元素`A[i]`进行交换，这样元素`A[i]`就会与当前有序区间`[1, i - 1]`形成新的有序区间`[1, i]`。于是在n趟操作后，所有元素就会是有序的。

算法逻辑：总共需要进行n趟操作，每趟操作选出待排序部分`[i, n]`中最小的元素，令其与`A[i]`交换，总复杂度为`O(n^2)`。

> 代码示例:

```C++
    void selectSort()
    {
        for(int i = 0; i < n; i++)
        {
            int k = i;
            for(int j = i; j <= n; j++)
            {
                if(A[j] < A[k])
                    k = j;
            }
            int temp = A[i];
            A[i] = A[k];
            A[k] = temp;
        }
    }
```

### 4.1.2 插入排序

直接插入排序是指，对序列A的n个元素`A[1] ~ A[n]`，令i从2到n枚举，进行`n - 1`趟操作。假设某一趟时，序列A的前`i - 1`个元素`A[1] ~ A[i - 1]`已经有序，而范围`[i, n]`还未有序，那么该趟从范围`[1, i - 1]`中寻找某个位置j，使得将`A[i]`插入位置j后（此时`A[j] ~ A[i - 1]`会后移一位至`A[j + 1] ~A[i]`），范围`[1, i]`有序。

插入排序是将待插入元素一个个插入初始已有序部分中的过程，而插入位置的选择遵循了使插入后仍然保持有序的原则，具体做法一般是从后往前枚举已有序部分来确定插入位置。

> 代码示例:

```C++
    int A[maxn], n; // n为元素个数，数组下标为0~n-1
    void insertSort()
    {
        for(int i = 1; i <= n-1; i++)
        {
            int temp = A[i], j = i;
            while(j > 0 && temp < A[j-1])
            {
                A[j] = A[j - 1];
                j--;
            }
            A[j] = temp;
        }
    }
```

### 4.1.3 排序题与sort函数的应用

1. cmp函数的编写

使用sort进行排序时，需要提供cmp函数实现的排序规则。比如，经常会出现类似这样的要求：对所有学生先按分数从高到低排序，分数相同的按姓名的字典序从小到大排序。

需要完成的排序规则可以等价表述如下：

1) 如果两个学生分数不相同， 那么分数高的排在前面。
2) 否则， 将姓名字典序小的排在前面。

> 代码示例:

```C++
    bool cmp(Student a, Student b)
    {
        if(a.score != b.score) return a.score > b.score;
        else return strcmp(a.name, b.name) < 0;
    }
```

`strcmp`函数是`string.h`头文件下用来比较两个`char`型数组的字典序大小的，其中`strcmp(str1, str2)`当`str1`的字典序小于`str2`时返回一个负数，当`str1`的字典序等于`str2`时返回0，当`str1`的字典序大于`str2`时返回—个正数。

> 练习1：

[PAT A1025]()

## 4.2 散列

### 4.2.1 散列的定义与整数散列

一般来说，散列(Hash)可以浓缩成一句话“将元素通过一个函数转换为整数，使得该整数可以尽量唯一地代表这个元素”。其中把这个转换函数称为散列函数H，也就是说，如果元素在转换前为key，那么转换后就是一个整数`H(key)`。

那么对key是整数的情况来说，常用的散列函数有**直接定址法(或是线性变换)**、**平方取中法**、**除留余数法**等，