# 第十一章 提高篇(5) ——动态规划专题

## 11.1 动态规划的递归写法和递推写法

动态规划是一种非常精妙的算法思想，它没有固定的写法、极其灵活，常常需要具体问题具体分析。

### 11.1.1 什么是动态规划

动态规划(Dynamic Programming, DP)是一种用来解决一类最优化问题的算法思想。简单来说，动态规划将一个复杂的问题分解成若干个子问题，通过综合子问题的最优解来得到原问题的最优解。需要注意的是，动态规划会将每个求解过的子问题的解记录下来，这样当下一次碰到同样的子问题时，就可以直接使用之前记录的结果，而不是重复计算。

一般可以使用递归或者递推的写法来实现动态规划，其中递归写法在此处又称作**记忆化搜索**。

### 11.1.2 动态规划的递归写法

先来讲解递归写法。通过这部分内容的学习，读者应能理解动态规划是如何记录子问题的解，来避免下次遇到相同的子问题时的重复计算的。

以斐波那契(Fibonacci)数列为例：

```C++
    int F(int n)
    {
        if(n == 0 || n == 1) return 1;
        else return F(n-1) + F(n-2);
    }
```

在计算过程中，递归式会涉及到很多重复的计算。事实上，由于没有及时保存中间计算的结果，实际复杂度会高达O(2n次方)，即每次都会计算F(n-1)和F(n-2)这两个分支，基本不能承受n较大的情况。

为了避免重复计算，可以开一个一维数组dp，用以保存已经计算过的结果，其中dp[n]记录F(n)的结果，并用dp[n]=-1表示F(n)当前还没有被计算过。

然后就可以在递归当中判断dp[n]是否是-1：如果不是-1，说明已经计算过F(n)，直接返回dp[n]就是结果；否则，按照递归式进行递归。代码如下：

```C++
    int F(int n)
    {
        if(n == 0 || n == 1) return 1;      // 递归边界
        if(dp[n] != -1) return dp[n];       // 已经计算过，直接返回结果
        else{
            dp[n] = F(n-1) + F(n-2);
            return dp[n];
        }
    }
```

通过已计划搜索，可以将复杂度从O(2n次方)降到O(n)。

通过上面的例子可以引申出一个概念： 如果一个问题可以被分解为若干个子问题，且这些子问题会重复出现，那么就称这个问题拥有**重叠子问题**(Overlapping Subproblems)。动态规划通过记录重叠子间题的解，来使下次碰到相同的子问题时直接使用之前记录的结果，以此避免大量重复计算。因此，**一个问题必须拥有重叠子问题，才能使用动态规划去解决**。

### 11.1.3 动态规划的递推写法

以经典的数塔问题为例，将一些数字排成数塔的形状，其中第一层有一个数字，第二层有两个数字……第n层有n个数字。现在要从第一层走到第n层，每次只能走向下一层连接的两个数字中的一个，问：最后将路径上所有数字相加后得到的和最大是多少？

注意到：如果要求出“从位置（1，1）到达最底层的最大和dp[1][1]”，那么一定要先求出它的两个子问题“从位置（2，1）到达最底层的最大和dp[2][1]”和“从位置（2，2）到达最底层的最大和dp[2][2]”，即进行了一次决策，写成式子就是：

`dp[1][1] = max(dp[2][1], dp[2][2]) + f[1][1]`

由此可以归纳得到：如果要求出dp[i][j]，那么一定先求出两个子问题：“从位置（i+1, j）到达最底层的最大和dp[i+1][j]”和“从位置（i+1, j+1）到达最底层的最大和dp[i+1][j+1]”，携程式子就是：

`dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + f[i][j]`

把dp[i][j] 称为问题的状态，而把上面的式子称作状态转移方程，它把状态dp[i][j]转移为dp[i+1][j]和dp[i+1][j+1]。可以发现，数塔的最后一层的dp值总是等于元素本身，即dp[n][j] ＝ f[n][j] (1≤n)，把这种可以直接确定其结果的部分称为边界，而动态规划的递推写法总是从这些边界出发，通过状态转移方程扩散到整个dp数组。

下面根据这种思想写出动态规划的代码：

```C++
    #include <cstdio>
    #include <algorithm>
    using namespace std;
    const int maxn = 1000;
    int f[maxn][maxn], dp[maxn][maxn];

    int main()
    {
        int n;
        scanf_s("%d", &n);
        for(int i = 1; i <= n; i++)
        {
            for(int j = 1; j <= n; j++)
            {
                scanf_s("%d%d", &f[i][j]);      // 输入数塔
            }
        }

        // 边界
        for(int j = 1; j <= n; j++)
        {
            dp[n][j] = f[n][j];
        }

        // 从n-1层不断往上计算出dp[i][j]
        for(int i = n-1; i>= 1; i--)
        {
            for(int j = 1; j <= i; j++)
            {
                // 状态转移方程
                d[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + f[i][j];
            }
        }
        printf("%d\n", dp[1][1]);
        return 0;
    }
```

显然，使用递归也可以实现上面的例子（即从dp[1][1]开始递归，直至到达边界时返回结果）。两者的区别在于：使用递推写法的计算方式是**自底向上**(Bottom-up Approach)，即从边界开始，不断向上解决问题，直到解决了目标问题；而使用递归写法的计算方式是**自顶向下**(Top-down Approach)，即从目标问题开始，将它分解成子问题的组合，直到分解至边界为止。

通过上面的例子再引申出一个概念：如果一个问题的最优解可以由其子问题的最优解有效地构造出来，那么称这个问题拥有**最优子结构**(Optimal Substructure)。最优子结构保证了动态规划中原问题的最优解可以由子问题的最优解推导而来。因此，一个问题必须拥有最优子结构，才能使用动态规划去解决。

需要指出，一个问题**必须拥有重叠子问题和最优子结构**，才能使用动态规划去解决。下面指出这两个概念的区别：

1. **分治与动态规划**。分治和动态规划都是将问题分解为子问题，然后合并子问题的解得到原问题的解。但是不同的是，分治法分解出的子问题是不重叠的，因此分治法解决的问题不拥有重叠子问题，而动态规划解决的问题拥有重叠子问题。

2. **贪心与动态规划**。贪心和动态规划都要求原问题必须拥有最优子结构。二者的区别在于，贪心法采用的计算方式类似于上面介绍的“自顶向下”，但是并不等待子问题求解完毕后再选择使用哪一个，而是通过一种策略直接选择一个子问题去求解，没被选择的子问题就不去求解了，直接抛弃。

## 11.2 最大连续子序列和

