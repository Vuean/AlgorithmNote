# 第九章 提高篇(3)——数据结构专题(2)

## 9.1 树与二叉树

### 9.1.1 树的定义与性质

树是用来概括传递关系的一种数据结构。其中树根抽象为根结点(root)，且对一棵树来说最多存在一个根结点；把树叶概括为叶子结点(leaf)，且叶子结点不再延伸出新的结点；把茎干和树枝统一抽象为边(edge)，且一条边只用来连接两个结点(一个端点一个)。这样，树就被定义为由若于个结点和若干条边组成的数据结构，且在树中的结点不能被边连接成环。

> 树的概念与性质

1. 树可以没有结点，这种情况下把树称为**空树**(empty tree)。

2. 树的层次(layer)从根结点开始算起，即根结点为第一层，根结点子树的根结点为第二层，以此类推。

3. 把结点的子树棵数称为结点的度(degree)，而树中结点的最大的度称为树的度（也称为树的宽度）。

4. 由于一条边连接两个结点，且树中不存在环，因此对有n个结点的树，边数一定是n-1。且**满足连通、边数等于顶点数减1的结构一定是一棵树**。

5. 叶子结点被定义为度为0的结点，因此当树中只有一个结点（即只有根结点）时，根结点也算作叶子结点。

6. **结点的深度**(depth)是指从根结点(深度为1)开始自顶向下逐层累加至该结点时的深度值；**结点的高度**(height)是指从最底层叶子结点(高度为1)开始自底向上逐层累加至该结点时的高度值。**树的深度是指树中结点的最大深度**，**树的高度是指树中结点的最大高度**。**对树而言，深度和高度是相等的**。

7. 多棵树组合在一起称为森林(forest)，即森林是若干棵树的集合。

### 9.1.2 二叉树的递归定义

> 二叉树的定义

1. 要么二叉树没有根结点，是一棵空树。

2. 要么二叉树由根结点、左子树、右子树组成，且左子树和右子树都是二叉树。

> 二叉树与度为2的树的区别：

对树来说，结点的子树是不区分左右顺序的，因此度为2的树只能说明树中每个结点的子结点个数不超过2。而二叉树虽然也满足每个结点的子结点个数不超过2，但它的左右子树是严格区分的，不能随意交换左子树和右子树的位置，这就是二叉树与度为2的树最主要的区别。

> 特殊的二叉树

1. **满二叉树**：每一层的结点个数都达到了当层能达到的最大结点数。

2. **完全二叉树**：除了最下面一层之外，其余层的结点个数都达到了当层能达到的最大结点数，且**最下面一层只从左至右连续存在**若干结点，而这些连续结点右边的结点全部不存在。

### 9.1.3 二叉树的存储结构与基本操作

1. 二叉树的存储结构

    一般来说，二叉树使用链表来定义。和普通链表的区别是，由于二叉树每个结点有两条出边，因此指针域变成了两个一分别指向左子树的根结点地址和右子树的根结点地址。如果某个子树不存在，则指向NULL，其他地方和普通链表完全相同，因此又把这种链表叫作**二叉链表**，其定义方式如下：

    ```C++
        struct node{
            typename data;  // 数据域
            node* lchild;   // 指向左子树根结点的指针
            node* rchile;   // 指向右子树根结点的指针
        };
    ```

    由于在二叉树建树前根结点不存在，因此其地址一般设为NULL:

    ```C++
        node* root = NULL;
    ```

    新建结点：

    ```C++
        // 生成一个新结点，v为结点权值
        node* newNode(int v){
            node* Node = new node;
            Node->data = v;
            Node->lchild = Node->rchile = NULL;
            return Node;
        }
    ```

2. 二叉树结点的查找、修改

    查找操作是指在给定数据域的条件下，在二叉树中找到所有数据域为给定数据域的结点，并将它们的数据域修改为给定的数据域。常通过递归操作来完成查找、修改操作。

    ```C++
        void search(node* root, int x, int newdata){
            if(root == NULL){
                return;
            }
            if(root->data == x){
                root->data = newdata;
            }
            search(root->lchild, x, newdata);
            search(root->rchile, x, newdata);
        }
    ```

3. 二叉树结点的插入

    二叉树结点的插入位置就是数据域在二叉树中查找失败的位置。而由于这个位置是确定的，因此在递归查找的过程中一定是只根据二叉树的性质来选择左子树或右子树中的一棵子树进行递归，且最后到达空树（死胡同）的地方就是查找失败的地方，也就是结点需要插入的地方。由此可以得到二叉树结点插入的代码：

    ```C++
        // insert函数将在二叉树中插入一个数据域为x的新结点
        // 注意根结点指针root要使用引用，否则插入不会成功
        void insert(node* &root, int x){
            if(root == null){
                root = newNode(x);
                return;
            }
            if(由二叉树的性质，x应该插在左子树){
                insert(root->lchild, x);
            }else{
                insert(root->rchile, x);
            }
        }
    ```

    上述代码中，很关键的一点是根结点指针root使用了引用&。一般来说，如果函数中需要新建结点，即对二叉树的结构做出修改，就需要加引用；如果只是修改当前已有结点的内容，或仅仅是遍历树，就不用加引用。

4. 二叉树的创建
